# 3장 네트워크 통신하기
## 3.1 유니캐스트, 멀티캐스트, 브로드캐스트, 애니캐스트
통신 방식은 목적지 주소를 기준으로 구분함
### 유니캐스트
- 1:1 통신
- 출발지와 목적지가  1:1로 통신
- 실제 대부분의 통신 방식
- IPv4, IPv6
- ex) HTTP

### 브로드캐스트
- 1:ALL 통신
- 동일 네트워크에 존재하는 모든 호스트가 목적지
- 주로 유니캐스트 통신 전, 상대방의 정확한 위치를 알기 위해 사용
- IPv4
- ex) ARP

### 멀티캐스트
- 1:Group 통신
- 하나의 출발지에서 다수의 특정 목적지로 전송
- IPTV와 같은 실시간 방송을 볼 때, 사내방송 등 단방향으로 다수에게 동시에 같은 내용을 전달할 때 사용
- IPv4, IPv6
- ex) 방송

### 애니캐스트
- 1:1 통신
- 목적지는 동일 그룹내에서 가장 가까운 호스트
- IPv4에서 일부 기능 구현, IPv6는 모두 구현
- 가장 가까운 DNS를 찾거나 게이트 웨이를 찾는 기능에 사용
- ex) DNS


### BUM 트래픽
- B(Broadcast), U(Unkown Unicast), M(Multicast)
- Unknwon Unicast
  - 목적지 주소는 명시돼있지만, 네트워크에서의 동작은 Broadcast와 같을 때 
- BUM은 유니캐스트이지만, 실제 겉으로 보이는 동작은 브로드 캐스트에 가까움


## 3.2 MAC 주소
- MAC(Media Access Control)
- 2계층에서 통신을 위해 NIC에 할당된 고유 식별자
- 이더넷과 와이파이를 포함한 대부분의 IEEE 802 네트워크 기술에서 2계층 주소로 사용됨
- 네트워크에 접속하는 모든 장비는 MAC주소를 가지고 이를 이용해 통신함
- MAC 주소는 단말에 종속되지 않고 NIC에 종속됨
  - 단말은 NIC 여러 개를 가질 수 있으므로, MAC 주소도 여러 개 가질 수 있음 ex) 멀티레이어 스위치, 라우터  

### MAC 주소 체계
- 하드웨어에 고정되어있고 변경할 수 없음
  - 모든 장비마다 전부 다름
  - 네트워크 장비 제조업체에 주소 풀을 주고, 그 안에서 자체적으로 MAC 주소를 할당함 => Vendor Code
- 48bit 16진수 12자리 
  ![](https://velog.velcdn.com/images%2Fsource39%2Fpost%2Fcc97d03c-884c-46e5-bc3a-2c71a653fbb6%2Fimage.png)
- 앞의 24bit는 제조사 코드, 뒤의 24bit는 제조사 자체 할당
- NIC에 MAC 주소가 할당되어 있는데, 이 주소를 변경하기는 어렵지만 가능은 함

### MAC 주소 동작
- 과정
  1. 전기신호가 들어오면 2계층에서 데이터 형태(패킷)로 변환하여 내용을 구분함
  2. 도착지 MAC 주소를 확인
  3. 폐기 or 수신
    - 도착지 MAC 주소가 자신의 MAC주소와 다르면 패킷을 폐기
    - 목적지 주소가 자신의 MAC 주소이거나 브로드캐스트, 멀티캐스트와 같은 그룹 주소이면 패킷 정보를 상위 계층으로 넘겨줌
- 예외
  - 다른 목적지를 가진 패킷을 분석하거나 수집해야 할 경우, 무차별 모드로 NIC을 구성함
  - 무차별 모드는 자신의 MAC 주소와 상관없는 패킷이 들어와도 이를 처리함

## 3.3 IP 주소
- 대부분의 네트워크가 TCMP/IP로 동작하므로, 3계층 IP 주소를 사용함
- 3계층 주소의 특징
  - 사용자가 변경 가능한 논리 주소
  - 주소에 레벨이 있음
    - 그룹을 의미하는 네트워크 주소, 호스트 주소로 나뉨

### IP 주소 체계
- IPv4: 32bit (주로 사용)
- IPv6: 128bit
- 8bit단위로 나누고 10진수로 표기함
![](https://user-images.githubusercontent.com/88179702/168206320-a2ca2aee-28b2-4503-8260-06d96c88df8b.png)
- 네트워크 주소
  - 호스트들을 모은 네트워크를 지칭하는 주소
  - 네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 함
- 호스트 주소
  - 하나의 네트워크 내에 존재하는 호스트들을 구분하기 위한 주소
- **IP주소의 네트워크 주소와 호스트 주소는 둘을 구분하는 경계점이 고정돼있지 않음** 
- 필요한 호스트 IP 개수에 따라 네트워크 크기를 다르게 할당하는 클래스 개념을 사용함
- ![클래스](https://user-images.githubusercontent.com/88179702/168206696-e935d849-5cab-4772-a754-d03ef44b30c5.png)
  - A클래스
    - 네트워크 주소: 1개 옥텟, 호스트 주소: 3개 옥텟
    - 2^8개의 네트워크와, 한 네트워크당 2^24개의 호스트 주소를 가짐
    - 앞 옥텟의 주소가 0~127이면 A클래스(로컬호스트)
  - B클래스
    - 네트워크 주소: 2개 옥텟, 호스트 주소: 2개 옥텟
    - 2^16개의 네트워크와, 한 네트워크당 2^16개의 IP를 가짐
    - 앞 옥텟의 주소가 128~191이면 B클래스
  - C클래스
    - 네트워크 주소: 3개 옥텟, 호스트 주소: 1개 옥텟
    - 2^24개의 네트워크와, 한 네트워크당 2^8개의 호스트를 가짐
    - 앞 옥텟의 주소가 192~223이면 C클래스
  - D클래스
    - 멀티캐스트
    - 앞 옥텟의 주소가 224~239면 D클래스
  - E클래스
    - 예약
- ex) 네트워크에서 사용 가능한 호스트 개수 파악   
  - 네트워크 주소: 172.16.0.0
  - 브로드캐스트 주소: 172.16.255.255
  - 유효 IP 범위: 172.16.0.~172.16.255.254

### 클래스풀과 클래스리스
- 클래스풀
  - 클래스 기반의 IP 주소 체계
- 클래스리스
  - IP 주소 부족과 낭비 문제를 해결하기 위해 등장
  - 네트워크와 호스트 주소를 나누는 구분자인 **서브넷 마스크**를 사용함
  - 서브넷 마스크
    -255는 네트워크 주소 부분, 0은 호스트 주소 부분 
    - A클래스 : 255.0.0.0 or /8
    - B클래스 : 255.255.0.0 or /16
    - C클래스 : 255.255.255.0 or /24
  - ex) IP: 103.9.32.146, 서브넷 마스크: 255.255.255.0
    => 네트워크 주소: 103.9.32.0, 호스트 주소: 0.0.0.146 
  - 서버나 PC에 IP 주소를 부여할 때 서브넷 마스크가 필요함

### 서브네팅
- 클래스리스 네트워크의 가장 큰 특징
- 옥텟 단위로 구분되는 서브네팅은 쉽지만, 실제로는 옥텐단위보다 더 잘게 쪼개 2진수의 1비트 단위로 분할함
- 서브네팅은 네트워크 사용자 입장과 네트워크 설계자 입장에서의 고려할 요소와 범위가 다름
- 네트워크 사용자 입장
  - 네트워크에서 사용할 수 있는 IP 범위 파악
  - 기본 게이트웨이와 서브넷 마스크 설정이 제대로 돼있는지 확인
  - 주어진 네트워크 범위 밖의 IP를 할당하거나 서브넷 마스크를 잘못 입력하면, 특정 범위 단말과 통신에 문제가 생기거나 외부 네트워크 전체에 통신하지 못하게 됨
  - 네트워크 유효 범위 파악하는 방법(복잡한 서브네팅 방법)
    1. 내 IP를 2진수로 표현
    2. 서브넷 마스크를 2진수로 표현
    3. 2진수 AND 연산으로 서브네팅된 네트워크 주소를 알아냄
    4. 호스트 주소 부분을 2진수 1로 모두 변경해 브로드캐스트 주소를 알아냄
    5. 유효 IP 범위를 파악함. 서브네팅된 네트워크 주소+1은 유효 IP 중 가장 작은 IP
    6. 브로드캐스트 주소-1은 유효 IP 중 가장 큰 IP
    7. 2진수로 연산되어있는 결과값을 10진수로 변환함 

| | |103|9|32|146|
|---|:---:|:---:|:---:|:---:|:---:|
|**1.IP주소**|103.9.32.146|01100111|00001001|00100000|10010010|
|**2.서브넷**|255.255.255.192|11111111|11111111|11111111|11000000|
|**3.네트워크 주소**|103.9.32.128|01100111|00001001|00100000|10000000|
|**4.브로드캐스트 주소**|103.9.32.191|01100111|00001001|00100000|10111111|
|**5.첫 번째 주소**|103.9.32.129|01100111|00001001|00100000|10000001|
|**6.마지막 주소**|103.9.32.146|01100111|00001001|00100000|10111110|

  - 간단한 서브네팅 방법
    - IP주소: 103.9.32.146 
    1. 서브넷 마스크를 2진수로 변환
      - 255.255.255.192 => 11111111.11111111.11111111.11000000
    2. 현재의 서브넷이 가질 수 있는 최대 IP 개수 크기를 파악함 
      - 2^6=64
    3. 64의 배수로 나열하여 기준이 되는 네트워크 주소를 파악함. 첫 블록은 0부터 시작하고, 각 네트워크의 마지막 주소가 브로드 캐스트 주소임
      - 0~63/64~127/128~191/192~255
    4. 103.9.32.146에서 호스트 주소 146이 속한 네트워크를 선택함
      - 128~191
    5. 필요한 주소를 정리함
      - 네트워크 주소: 103.9.32.128(첫 번째 숫자)
      - 브로드캐스트 주소: 103.9.32.191(마지막 숫자)
      - 유효 IP 범위: 103.9.32.129~103.9.32.190(네트워크 주소와 브로드캐스트 주소 사이)

- 네트워크 설계자 입장
  - 네트워크 설계 시 네트워크 내에 필요한 단말을 고려한 네트워크 범위 설계해야 함
    - 서브넷된 하나의 네트워크에 IP를 몇개나 할당해야 하는가?(몇 대의 PC가 있는가?)
    - 서브넷된 네트워크가 몇 개 필요한가?
  - ex) 회사 네트워크 설계
    - 12개의 지사
    - 12개의 IP가 필요한 PC, 복합기, IP 카메라 운영 예정
    - 네트워크 : 103.9.32.0/24
    1. 서브넷된 하나의 네트워크에 12개의 IP를 할당해야 함
    2. 네트워크는 2진수의 배수로 커지므로 4,8,16,32,64,128,256개 단위로 네트워크를 할당
       12개의 IP를 수용할 수 있는 가장 작은 네트워크는 16개 이므로 16개 할당함
       =>네트워크 주소와 브로드캐스트 주소로 사용할 2개의 IP를 제외해야하므로 실제 사용할 수 있는 IP는 14개임
    3. 16개짜리 네트워크 12개를 확보함. 16의 배수를 0부터 나열해 네트워크 주소 확인
    4. 총 16개 네트워크 중 12개 네트워크를 할당함

|네트워크 주소|브로드캐스트 주소|유효 IP 범위|할당|
|---|---|---|---|
|103.9.32.0|103.9.32.15|103.9.32.1~14|네트워크 장비 주소|
|103.9.32.16|103.9.32.31|103.9.32.17~30|시리얼 구간(라우터 중간 네트워크 할당용)|
|103.9.32.32|103.9.32.47|103.9.32.33~46|1번 지사|
|103.9.32.48|103.9.32.63|103.9.32.49~62|2번 지사|
|...|...|...|n번 지사|
|103.9.32.208|103.9.32.223|103.9.32.209~222|12번 지사|

  - 네트워크를 설계할 때는 사설 IP 대역을 사용하는 것이 좋음
  - 네트워크 전파가 단순한게 잘 설계된 네트워크이고, 네트워크 전파가 복잡해지면 잘못 설계된 네트워크임

### 공인 IP와 사설 IP
- 공인 IP: 인터넷에 접속하기 위한 유일한 식별자 IP
- 사설 IP: 인터넷에 연결하지 않거나 NAT를 사용해 개인적으로 네트워크를 구성했을 때의 IP
  - 사설 IP를 사용하면 인터넷에 직접 접속하진 못하지만 IP를 변환해주는 NAT 장비에서 공인 IP로 변경한 후 인터넷 접속 가능
  - ex)공유기
- 클래스별 사설 IP 주소 (RFC 1918)

|네트워크 주소|IP 범위|클래스 크기|
|---|---|---|
|10.0.0.0/8|10.0.0.0~10.255.255.255|A클래스 1개|
|172.16.0.0/12|172.16.0.0~172.31.255.255|B클래스 16개|
|192.168.0.0/16|192.168.0.0~192.168.255.255|C클래스 256개|

- 사설 네트워크를 구축할 때 NAT를 사용해 인터넷에 연결하더라도 RFC에 명시된 사설 IP 대역을 사용해야 함
- 규모가 큰 엔터프라이즈 네트워크에서는 대부분 A 클래스 크기인 10.0.0.0/8 네트워크를 사용
- 모바일 디바이스는 B클래스 172.x.x.x를 사용해 테더링
- 규모가 작은 네트워크는 C 클래스 192.168.x.0/24를 사용 => 공유기

## 3.4 TCP와 UDP
- 2,3계층 프로토콜의 목적: 목적지를 정확히 찾아가기 위한 주소 제공
- 4계층 프로토콜의 목적: 단말 안의 여러 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고, 패킷 순서가 바뀌지 않도록 조합

### 4계층 프로토콜(TCP, UDP)과 서비스 포트
- 헤더에 추가되는 중요한 정보
  - 각 계층을 정의하는 정보
    - 수신 측의 동일 계층에서 사용하기 위한 정보
    - 2계층: MAC 주소
    - 3계층: IP 주소
    - 4계층: Seq 번호, ACK 번호
  - 상위 프로토콜 지시자 정보
    - 디캡슐레이션 과정에서 상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용
    - 2계층: 이더 타입
    - 3계층: 프로토콜 번호
    - 4계층: 포트 번호
![상위 프로토콜 지시자 정보](https://user-images.githubusercontent.com/88179702/168737365-f928c77d-431e-4045-812d-0f4e15e41669.png)

  - TCP/IP 프로토콜 스택
    - 2,3계층의 상위 프로토콜 지시자(이더타입, 프로토콜 번호)는 출발지와 도착지를 구분하지 않음
    - 4계층 프로토콜 지시자인 포트번호는 출발지와 목적지를 구분함
    - 클라이언트용 프로그램과 서버용 프로그램을 구분해 개발
      - 포트 번호의 기준은 서버의 포트
        - 서버에서 응답할 시에 출발지와 도착지 포트 번호는 요청 패킷과 응답 패킷이 반대가 됨 
      - 웰노운 포트
        - HTTP TCP 80
        - HTTPS TCP 443
        - SMTP TCP 25

### TCP
- 4계층의 특징을 대부분 포함하고 있음
- 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장함
  - 패킷에 번호를 부여(Sequence Number)
  - 잘 전송되었는지 응답함(Acknowledge Number)
  - 한꺼번에 보낼 수 있는 전송 크기(Window Size)를 고려해 통신함
- 패킷 순서, 응답 번호
  - 순서를 부여하는 것: 시퀀스 번호
  - 응답 번호를 부여하는 것: ACK 번호 
  - ![image](https://user-images.githubusercontent.com/88179702/168743172-bb36c56d-589e-44c0-bfdd-55e4059e6beb.png)
    1. 송신자가 수신자에게 SEQ0번 패킷을 보냄
    2. 수신자는 0번 패킷을 잘 받았으니 1번 패킷을 보내달라는 의미로 ACK=1을 보냄. 이 때 수신측에서는 처음 보내는 패킷이므로 SEQ=0도 보냄
    3. 송신측은 수신측에서 요청한 SEQ=1 패킷과, 수신측의 0번 SEQ를 잘 받았다는 의미로 ACK=1을 전송함
- 윈도 사이즈와 슬라이딩 윈도
  - 윈도 사이즈
    - 한번에 받을 수 있는 데이터의 크기 
    - 사용 이유
      - TCP에서 패킷이 잘 전송되었는지 확인하는 ACK 패킷 송수신때문에 통신시간이 늘어남 => 왕복지연시간(RTT)가 늘어남
      - 따라서 데이터를 보낼 때 패킷을 여러 개 한꺼번에 보내고 하나의 응답을 받음
  - 슬라이딩 윈도 
    - 네트워크 상태가 안좋으면 패킷 유실의 가능성이 커지므로 네트워크 상황에 따라 윈도 사이즈를 조절하는 것
    - TCP 헤더에서 윈도 사이즈로 표현할 수 있는 최대 크기: 2^16
      - 64K는 너무 작기 때문에 뒤의 숫자를 무시해서 10배, 100배씩 키워나감
    - 데이터에 유실이 발생하면 윈도 사이즈를 절반으로 떨어트리고, 정상적으로 통신이 될 경우 하나씩 늘림
- 3방향 핸드셰이크
  - 유실 없는 안전한 통신을 위해 통신 시작 전 3번의 패킷을 주고받는 사전 연결 작업
  - 패킷 네트워크에서는 동시에 만흔 상대방과 통신하므로, 통신 전 각 통신에 필요한 리소스를 미리 확보함
    1. 서버는 서비스를 제공하기 위해 클라이언트의 접속을 받을 수 있는 LISTEN 상태로 대기함
    2. 클라이언트에서 서버로 Syn 패킷을 보내 통신을 시도함 (SYN-SENT 상태)
    3. 서버에서 Syn을 받으면 SYN-RECEIVE 상태가 되고, Syn, Ack로 응답함
    4. 응답을 받은 클라이언트는 ESTABLISHED 상태가 되고, 그에 대한 응답을 서버에 Ack로 보냄
    5. 서버에서도 응담을 받고 ESTABLISHED 상태가 됨
  - 기존 통신과 새로운 연결 시도를 구분하기 위해 헤더에 Flag 값을 넣음
  - TCP Flag (0 or 1)
    - SYN
      - 연결 시작 할 때 1
    - ACK
      - ACK 번호가 유효할 경우 1로 표시
      - 초기 SYN을 제외한 패킷은 모두 응답이므로 ACK=1
    - FIN
      - 연결 종료 시 1
      - 데이터 전송을 마친 후 정상적인 양방향 종료시 사용
    - RST
      - 연결 종료 시 1
      - 강제종료를 위해 연결을 일방적으로 끊을 때 사용
    - URG
      - 긴급 데이터인 경우 1
    - PSH
      - 서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용프로그램으로 즉시 전달할 것을 지시할 때 1
  - ![image](https://user-images.githubusercontent.com/88179702/168747758-5e3303f7-c009-443d-8352-066cfd932a59.png)

### UDP
- 4계층 프로토콜이 가져야할 특징이 거의 없음
- 핸드셰이크 x, ACK/SEQ x, 윈도사이즈 사용 x, 플래그 x
- 데이터 전송을 보장하지는 않지만 매우 빠르게 전송
- 사용처
  - 음성 데이터나 실시간 스트리밍과 같이 시간에 민감한 프로토콜이나 애플리케이션
  - 사내방송이나 증권시세 데이터 전송에 사용되는 멀티캐스트처럼, 단방향으로 다수의 단말과 통신하는 환경
- UDP에서 첫 데이터는 리소스 확보를 위해 인터럽트(Interrupt)를 거는 용도로 사용되고 유실됨
- 혹은 연결 확립은 TCP 프로토콜을 사용하고 실제데이터만 UDP를 이용함

### TCP와 UDP 비교

|TCP|UDP|
|---|---|
|연결 지향|비연결형|
|오류 제어 o|오류 제어 x|
|흐름 제어 o|흐름 제어 x|
|유니캐스트|유니캐스트, 멀티캐스트, 브로드캐스트|
|전이중(Full Duplex)|반이중(Half Duplex)|
|데이터 전송|실시간 트래픽 전송|


## 3.5 ARP
- 상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜
  - 2계층 MAC주소와 3계층 IP 주소는 아무 관계가 없음
    - MAC 주소: 하드웨어 생산업체가 임의로 할당한 NIC에 종속된 주소
    - IP주소: 직접 할당하거나 DHCP를 이용해 자동으로 할당받는 주소
  - 실제 통신은 IP주소를 기반으로 일어남

### ARP란?
- MAC주소와 IP 주소를 연결시켜주는 프로토콜
![ARP 프로토콜 필드](https://user-images.githubusercontent.com/88179702/168771371-75bf493f-3d2f-437b-9cb9-90c48fc342bb.png)
- 처음 통신을 시도할 때 IP주소는 알고 있어 3계층은 캡슐화 할 수 있지만, MAC 주소를 알 수 없어 2계층 캡슐화를 할 수 없음
- 간략한 과정 
  - ARP 브로드캐스트로 네트워크 전체에 상대방의 MAC 주소 질의
  - 수신자는 ARP 브로드캐스트를 받고, ARP 프로토콜을 이용해 자신의 MAC 주소를 응답함
  - 출발지와 목적지 모두 상대방의 MAC 주소를 학습하고, 이후 패킷을 정상적으로 인캡슐레이션해서 전달함
- 패킷을 보낼 때 마다 ARP 브로드캐스트를 수행하면 효율성이 저하됨 => ARP 테이블 사용
  - 일정 시간 동안 통신이 없으면 삭제됨
- arp -a 명령으로 PC의 ARP 테이블 정보를 확인할 수 있음
- ARP 작업은 CPU에서 직접 수행하기 때문에 단시간에 많은 ARP 요청이 들어오면 큰 부하로 작용함
  - 해커들이 악용함
  - 공격에 대응하기 위해 네트워크 장비는 ARP 테이블 저장기간을 일반 PC보다 길게 설정
  - 많은 요청이 들어오면 필터링하거나 천천히 처리하거나 수동으로만 갱신하도록 설정하기도 함
 
### ARP 동작
- 주요 필드: 송신자 MAC주소, 송신자 IP주소, 수신자 MAC주소, 수신자 IP주소
- 예시 과정
  - 서버 A에서 서버 B로 ping을 보내려고 함
  - 서버 A에서는 3계층의 IP 주소까지 캡슐화하지만 목적지의 mAC 주소를 모르므로 정상적으로 패킷을 만들 수 없음 
  1. 서버 A는 서버 B의 MAC 주소를 알아내기 위해 ARP 브로드캐스트를 함
    - **브로드캐스트** 할 때 2계층 MAC 주소: 출발지는 자신의 MAC, 도착지는 브로드캐스트(FF-FF-FF-FF-FF-FF)
    - ARP 프로토콜 필드의 전송자 MAC과 IP 주소: 자신의 MAC과 IP 주소
    - ARP 프로토콜 필드의 대상자 MAC과 IP 주소: 00-00-00-00-00-00(MAC)과 대상 IP 주소
  2. 수신한 모든 단말은 ARP 프로토콜 내용을 확인하고 ARP 프로토콜 필드의 대상자 IP가 자신이 맞으면 처리, 아니면 버림
    - 서버 B에서는 ARP 요청의 대상자 IP가 자신이기 때문에 응답을 보내는데 **(유니캐스트)** , 이 때 송신자와 대상자의 위치가 바뀜
    - ARP 프로토콜 필드의 전송자 MAC과 IP 주소: 자신의 MAC과 IP 주소
    - ARP 프로토콜 필드의 대상자 MAC과 IP 주소: 대상자 MAC과 IP 주소
  3. 서버 A는 서버 B로부터 ARP 응답을 받아 자신의 ARP 캐시 테이블을 갱신함

### GARP
- Gratuitous ARP
- 대상자 IP 필드에 자신의 IP 주소를 채워 ARP 요청을 보냄
- 자신의 IP와 MAC 주소를 브로드캐스트로 알릴 목적으로 사용됨
- 송신자 MAC: 자신의 MAC, 송신자 IP: 자신의 IP
- 대상자 MAC: 00:00:00:00:00:00, 대상자 IP: 자신의 IP
- 사용 이유
  - IP 주소 충돌 감지
    - 자신에게 할당된 IP가 네트워크에서 이미 사용되고 있는지 GARP를 통해서 확인함
    - GARP 응답이 오면 네트워크 상에서 해당 IP를 이미 사용중인 단말이 있다는 것 => IP 주소 충돌 
  - 상대방(동일 서브넷 상의 다른)의 ARP 테이블 갱신
    - 가상 MAC 주소를 사용하지 않는 데이터베이스 HA 솔루션에서 주로 사용
    - 데이터베이스 HA는 주로 두 데이터베이스 서버가 하나의 가상 IP 주소로 서비스
    - 두 대 중 한대만 동작하고 한 대는 대기하는 액티브-스탠바이로 동작
    - 액티브 상태인 서버가 가상 IP 주소 요청에 응답하지만 MAC 주소는 실제 MAC 주소를 사용
  - HA(고가용성) 용도의 클러스터링, VRRP, HSRP
    - 클러스터링이나 FHRP의 GARP 사용은 네트워크에 있는 스위치 장비의 MAC 테이블 갱신이 목적
      - VRRP, HSRP는 FHRP의 일종임
    - 클러스터링 중간에 있는 스위치의 MAC 테이블은 마스터가 변경되었을 때 가상 MAC 주소의 위치를 업데이트 해야하므로 MAC 테이블 갱신이 필요
    - 슬레이브가 마스터로 역할이 변경되면 GARP를 전송하고, 스위치에서는 MAC 주소에 대한 포트 정보를 새로 변경해 테이블 갱신 
    - ![image](https://user-images.githubusercontent.com/88179702/168784701-b39f6888-d66f-4d3f-8c22-6f4bdb506041.png)

### RARP
- Reverse ARP
- IP 주소가 정해져 있지 않은 단말이 IP 할당을 요청할 때 사용
- 나 자신의 MAC 주소는 알지만 IP가 아직 할당되지 않아 IP를 할당해주는 서버에 요청
- 현재는 BOOTP와 DHCP로 대체되어 사용되지 않음
- 
