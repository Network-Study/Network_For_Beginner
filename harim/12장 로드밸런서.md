# 12장 로드밸런서
- 서비스의 안정성이나 가용량을 높이기 위해 서비스를 이중화 할 때는 서비스 자체적으로 HA 클러스터를 구성하기도 하지만, 복잡한 고려 없이 이중화를 손쉽게 구현하도록 로드밸런서를 많이 사용함
## 12.1 부하분산이란?
- 배경
  - 서비스를 단일 서버로 구성하면 해당 서버의 애플리케이션, 운영체제, 하드웨어에 장애가 발생했을 떄, 정상적인 서비스를 제공할 수 없음
  - 서비스 가용성을 높이기 위해 하나의 서비스는 보통 두 대 이상의 서버로 구성함
  - 단일 서버를 구성하거나 서버를 이중화해 서비스 호출을 분리한 경우, 서버 장애에 따라 서비스 장애가 발생함
    - 사용자에 따라 호출하는 서버의 IP가 다르기 때문에 어떤 서버에 장애가 발생하면 그 서버 IP를 이용하는 사용자는 서비스를 이용 하지 못하게 됨
  - 이런 문제점을 해결하기 위해 L4나 L7 스위치라는 **로드밸런서**를 사용함
- 로드밸런서란
  - 로드밸런서에는 동일한 서비스를 사용하는 다수의 서버가 등록되고, 사용자로부터 서비스 요청이 오면 로드밸런서가 받아 사용자별로 다수의 서버에 서비스 요청을 분산시켜 부하를 분산함
  - 로드밸런서에서는 서비스를 위한 가상 IP(VIP)를 하나 제공하고 ,사용자는 각 서버의 개별 IP 주소가 아닌 동일한 가상 IP를 통해 각 서버로 접근함
  - 각 서버의 서비스 상태를 체크해 서비스가 가능한 서버로만 사용자의 요청을 분산함

## 12.2 부하 분산 방법
- 부하를 다수의 장비에 분산시키기 위해 가상 IP 주소를 갖게됨
  - VIP(Virtual IP)라고도 하고 서비스 IP 주소라고도 함
- 각 서버의 실제 IP 주소를 Real IP (혹은 RIP)라고 함
- 로드밸런서의 가상 IP에 실제 서버들이 바인딩됨
- 사용자가 VIP로 서비스를 요청하면 해당 VIP에 연결된 리얼 IP로 해당 요청을 전달함
- ex)
|Real IP|서버 명|
|---|---|
|10.10.20.11|서버#1|
|10.10.20.12|서버#2|
|10.10.20.13|서버#3|

|VIP|서비스 포트|연결된 서버|
|---|---|---|
|10.10.10.1|http(80)|서버 #1, #2|
|10.10.10.1|https(443)|서버 #2, #3|

  - 서버는 세 대가 있음
  - 서버 1은 http, 3은 https 서비스데몬이 동작하고, 서비스 2는 http와 https서비스 데몬이 모두 동작함
  - 이 때 http 서비스는 서버 1,2 번으로 부하 분산 그룹을 설정하고, https 서비스는 서버 2,3,번으로 분산 그룹을 설정함
- 로드밸런서에 부하 분산을 위한 그룹을 만들 때는 IP 주소 뿐만 아니라 서비스 포트까지 지정해 만듦
  - 그래서 L4스위치라고도 함
  - 7계층 정보까지 확인해 처리하는 기능이 포함되는 경우에는 L7스위치라고 하기도 함
- 동일한 리얼 IP에서 서비스 포트마다 VIP를 다르게 설정할 수도 있고 리얼 IP의 서비스 포트와 ,VIP 포트도 서로 다르게 설정할 수 있음

## 12.3 헬스 체크
- 로드밸런서에서는 부하 분산을 하는 각 서버의 서비스를 주기적으로 헬스 체크해 정상적인 서비스쪽으로만 부하를 분산하고 비정상적인 서버는 서비스 그룹에서 제외해 트래픽을 보내지 않음
- 서비스 그룹에서 제외된 후에도 헬스체크를 계속 수행해 다시 정상으로 확인되면 서비스 그룹에 해당 장비를 다시 넣어 트래픽이 서버 쪽으로 보내지도록 해줌

### 헬스 체크 방식
- ICMP
  - VIP에 연결된 리얼 서버에 대해 ICMP(ping)로 헬스 체크를 수행하는 방법임
  - 단순히 서버가 살아있는지 여부만 체크하는 방법이므로 잘 사용하지 않음
- TCP 서비스 포트
  - 가장 기본적인 헬스 체크 방법
  - 로드밸런서에 설정된 서버의 서비스 포트를 확인하는 것
    1. 로드밸런서에서 서버의 서비스 포트 2000번을 등록했다면 로드밸런서에서는 리얼 IP의 2000번 포트로 SYN을 보냄
    2. 해당 리얼 IP를 가진 서버로부터 SYN,ACK를 받음
    3. 서버에 다시 ACK로 응답하고 FIN을 보내 헬스 체크를 종료함
  - SYN/SYN,ACK/ACK까지 3방향 핸드셰이크 과정
  - 실제 서비스 포트가 아닌 다른 서비스 포트로도 헬스체크를 할 수 있음
- TCP 서비스 포트: Half Open
  - TCP Half Open(절반 개방) 방식
  - 일반 TCP 서비스 포트를 확인할 때는 3방향 핸드셰이크를 거치지만, 헬스체크로 인한 부하를 줄이거나 정상적인 종료방식보다 빨리 헬스체크 세션을 끊기 위해 사용함
  - SYN을 보내고 SYN,ACK를 받지만 이후 ACK 대신 RST을 보내 세션을 끊음
- HTTP 상태 코드
  - 로드밸런서가 서버로 3방향 핸드셰이크를 거치고나서 HTTP를 요청해 정상적인 상태 코드(200 OK)를 응답하는지 여부를 체크해 헬스 체크 수행
  - TCP는 정상적으로 열리지만 웹서비스에대한 응답을 정상적으로 하지 못할 때 확인하는 방식
- 콘텐츠 확인(문자열 확인)
  - 로드밸런서에서 서버로 콘텐츠를 요청하고 응답받은 내용을 확인하여 지정된 콘텐츠가 정상적으로 응답했는지 여부를 확인하는 헬스체크 방법
  - 보통 특정 웹페이지를 호출해 사전에 지정한 문자열이 해당 웹페이지 내에 포함되어 있는지를 체크하는 기능
  - 이 헬스 체크 방식을 사용하면 로드 밸런서에서 직접 관리하는 서버의 상태 뿐만 아니라, 해당 서버의 백엔드의 상태를 해당 웹페이지로 체크할 수 있음
  - 앞단의 서버가 백엔드로 요청을 하고 백엔드에서 정상적인 결괏값으로 웹 페이지에 특정 문자열을 출력하게 해 백엔드 상태까지 확인하면서 헬스 체크를 수행하는 것
  - 유의사항
    - 단순히 서버에서 응답받은 문자열만 체크하면 정상적인 요청 결괏값이 아닌 문자열만 체크함
    - 그렇기 때문에 비정상적인 에러 코드에 대한 응답인 경우라도 해당 응답 내용에 헬스 체크를 하려 했던 문자열이 포함되어 있으면 헬스 체크를 정상으로 판단할 수 있음
    - 따라서 문자열을 이용해 헬스 체크를 수행할 때는 정상 코드 값도 중복으로 확인하거나 문자열 자체를 일반적이 아닌 특정 문자열로 지정해 결과가 정상일때만 성공하도록 해야 함

### 헬스 체크 주기와 타이머
- 주기(Interval)
  - 로드 밸런서에서 서버로 헬스 체크 패킷을 보내는 주기
- 응답 시간(Response)
  - 로드 밸런서에서 서버로 헬스 체크 패킷을 보내고 응답을 기다리는 시간
  - 해당 시간까지 응답이 오지 않으면 실패로 간주함
- 시도 횟수(Retries)
  - 로드 밸런서에서 헬스 체크 실패 시 최대 시도 횟수
  - 최대 시도 횟수 이전에 성공 시 시도 횟수는 초기화됨
- 타임 아웃(Timeout)
  - 로드밸런서에서 헬스체크 실패 시 최대 대기 시간
  - 헬스 체크 패킷을 서버로 전송한 후 이 시간 내에 성공하지 못하면 해당 서버는 다운됨
- 서비스 다운 시의 주기(Dead Interval)
  - 서비스의 기본적인 헬스 체크 주기가 아닌, 서비스 다운 시의 헬스 체크 주기
  - 서비스가 죽은 상태에서 헬스 체크 주기를 별도로 더 늘릴 때 사용

- 서비스 다운까지의 동작을 헬스 체크 주기와 시도 횟수, 응답시간으로 산정하거나 전체 타임아웃 시간으로 산정하기도 함

## 12.4 부하 분산 알고리즘
- 로드 밸런서가 리얼 서버로 부하를 분산할 때, 로드 밸런서에서는 사전에 설정한 분산 알고리즘을 ㅌㅇ해 부하 분산이 이루어짐
- 주요 분하 분산 알고리즘
  - 라운드 로빈
    - 현재 구성된 장비에 부하를 순차적으로 분산함
    - 총 누적 세션 수는 동일하지만 활성화된 세션 수는 달라질 수 있음
  - 최소 접속 방식
    - 현재 구성된 장비 중 가장 활성화된 세션 수가 적은 장비로 부하를 분산함
  - 가중치 기반 라운드 로빈
    - 라운드 로빈 방식과 동일하지만 각 장비에 가중치를 두어 가중치가 높은 장비에 부하를 더 많이 분산함
    - 처리 용량이 다른 서버에 부하를 분산하기 위한 분산 알고리즘
  - 가중치 기반 최소 접속 방식
    - 최소 접속 방식과 동일하지만 각 장비에 가중치를 부여해 가중치가 높은 장비에 부하를 더 많이 분산함
    - 처리 용량이 다른 서버에 부하를 분산하기 위한 분산 알고리즘
  - 해시
    - 해시 알고리즘을 이용한 부하 분산
    
### 라운드 로빈
- 특별한 규칙 없이 현재 구성된 장비에 순차적으로 돌아가면서 트래픽을 분산함
- EX) 서버가 세 대 있을 때 첫번째 요청은 1번 서버, 두번째 요청은 2번 서버, 세번째 요청은 3번 서버, 네번째 요청은 다시 1번 서버,,,,
- 순차적으로 모든 장비에 분산하므로 모든 장비의 총 누적 세션 수는 같아짐

### 최소 접속 방식
- 서버가 가진 세션 부하를 확인해 그것에 맞게 부하를 분산하는 방식
- 로드 밸런서에서는 서비스 요청을 각 자입로 보내줄 때마다 세션 테이블이 생성되기 때문에 각 장비에 연결된 현재 세션 수를 알 수 있음
- 최소 접속 방식은 각 장비의 세션 수를 확인해 현재 세션이 가장 적게 여녀결된 장비로 서비스 욫엉르 보내는 방식
- 서비스별로 세션 수를 관리하면서 분산해주므로 각 장비에서 처리되는 활성화 세션 수가 비슷하게 분산되면서 부하를 분산함

### 해시
- 해시 방식은 서버의 부하를 고려하지 않고 클라이언트가 같은 서버에 지속적으로 접속하도록 하기 위해 사용하는 부하 분산 방식임
- 서버 상태를 고려하는 것이 아니라 해시 알고리즘을 이용해 얻은 결괏값으로 어떤 장비로 부하를 분산할지 결정함
- 알고리즘에 의한 계산값이기 때문에 같은 알고리즘을 사용하면 항상 동일한 결괏값으로 서비스를 분산할 수 있음
- 알고리즘 계산에 사용되는 값들은 주로 출발지 IP 주소, 목적지 IP 주소, 출발지 서비스 포트, 목적지 서비스 포트를 사용함

### 장단점
- 라운드로빈, 최소접속방식은 부하를 비교적 비슷한 비율로 분산시킬 수 있다는 장점이 있음
- 하지만 동일한 출발지에서 로드 밸런서를 거친 서비스 요청이 처음 분산된 서버와 그 다음요청이 분산된 서버가 달라질 수 있어, 각 서버에서 세션을 유지해야 하는 서비스는 정상적으로 서비스되지 않음
- 해시방식은 항상 동일한 장비로 서비스가 분산된다는 장점이 있기 때문에 세션을 유지해야 하는 서비스에 적합한 분산방식임
- 하지만 알고리즘의 결괏값이 특정한 값으로 치우치면 부하 분산 비율이 한쪽으로 치우칠 수도 있음
- 서버 애플리케이션 개발에 여러 대의 서버가 사용될 것을 고려하지 않고 개발한 경우 해시를 사용함

## 12.5 로드 밸런서 구성 방식
- 구성 위치에 따라 2가지로 나눔
  - 원암(One-Arm) 구성
    - 로드 밸런서가 중간 스위치 옆에 연결되는 구성
    - 부하 분산을 수행하는 트래픽에 대해서만 로드 밸런서를 경유하고, 부하 분산을 수행하지 않는 트래픽은 로드 밸런서를 경유하지 않고 통신할 수 있음
  - 인라인(Inline) 구성
    - 서버로 가는 경로 상에 로드밸런서가 연결되는 구성
    - 부하 분산을 포함한 모든 트래픽이 로드 밸런서를 경유하는 구성

### 원암 구성
- 로드 밸런서가 중간 스위치 옆에 연결되는 구성
- LACP와 같이 다수의 인터페이스로 스위치와 연결된 경우에도 스위치 옆에 있는 구성이라면 원암 구성이라고 함
- 로드 밸런서와 스위치 간 두 개 이상의 인터페이스를 LACP가 아닌 서로 다른 네트워크로 로드 밸런서와 구성한 경우에도 원암 구성이 될 수 있음
- 트래픽이 로드 밸런서를 경유하는지 여부는 부하 분산을 이용한 트래픽인지 여부로 구분할 수 있음
- 부하 분산을 이용할 때는 로드 밸런서를 경유함
- 부하 분산을 이용하지 않을 때는 로드 밸런서를 경유하지 않음

### 인라인 구성
- 로드밸런서가 스위치에서 서버까지 가는 일직선상 경로에 있는 형태
- 트래픽이 흐르는 경로에 로드 밸런서가 있어서 서버로 향하는 트래픽이 로드 밸런서의 서비스를 받는지 여부와 상관없이 로드밸런서를 모두 통과함
- 모든 트래픽이 동일한 경로로 흐르므로 구성이 직관적이고 이해하기 쉬움
- 대신 모든 트래픽이 로드 밸런서를 경유하므로 로드 밸런서의 부하가 높아짐
- 인라인으로 로드밸런서를 선정할 때는 로드 밸런싱 성능과 패킷 스루풋 성능을 구별해 디자인 해야 함

## 12.6 로드 밸런서 동작 모드
- 로드 밸런서 동작 방식
  1. 트랜스패런트(Trnsparent: TP) 또는 브릿지(Bridge)
  2. 라우티드(Routed)
  3. DSR(Direct Server Return)

### 트랜스패런트 모드
- 트랜스패런트 구성은 로드 밸런서가 OSI 2계층 스위치처럼 동작하는 구성
- 즉, 로드 밸런서에서 서비스를 하기 위해 사용하는 VIP 주소와 실제 서버가 동일한 네트워크를 사용하는 구성
- 트랜스패런트 구성은 기존에 사용하던 네트워크 대역을 그대로 사용하기 때문에 로드 밸런서 도입으로 인한 IP 네트워크 재설계를 고려하지 않아도 되고, 네트워크에 L2 스위치를 추가하는 것과 동일하게 기존 망의 트래픽 흐름에 미치는 영향 없이 로드 밸런서를 구성할 수 있음
- 원암과 인라인 구성에서 모두 사용 가능
- ex) 트랜스패런트 모드에서 서비스 요청 시의 패킷 흐름
  - 사용자는 서비스  IP 인 로드밸런서의 VIP 주소 10.10으로 서비스를 요청
  - 로드 밸런서로 들어온 패킷은 목적지 IP 주소를 VIP에 바인딩되어있는 실제 서버 IP 주소로 변경하므로, 목적지 IP 주소는 10.10에서 10.11로 변경됨
  - 목적지 MAC주소도 실제 서버의 MAC 주소가 됨
  - 로드밸런서와 목적지 서버가 동일한 네트워크 대역이므로 출발지 MAC 주소는 변경되지 않음
  - 서비스 요청 패킷의 목적지 정보가 변경되면 실제 서버로 패킷이 전달됨
  - 로드 밸런서에서 서비스를 위한 VIP 주소가 실제 서버의 IP 주소로 변경해 전송하므로 목적지 NAT가 되었다고 함
- ex) 트랜스패런트 모드에서 서비스 응답 시의 패킷 흐름
  - 서버에서 사용자에게 응답할 때는 로드밸런서를 지나면서 요청할 때와 반대로 출발지의 IP 주소가 실제 서버의 IP에서 VIP 주소로 변경되지만 목적지 MAC 주소는 변경되지 않음
    - 서버에서 으답할 때 목적지 MAC 주소가 이미 게이트웨이의 MAC 주소를 갖고 잇어 변경할 필요가 없기 때문
  - 원암 구성에서 동일 네트워크에서 서비스를 호출할 때는 서비스 응답이 로드밸런서를 거치지 않을 수 있음 -> 문제 발생할 수 있음

### 라우티드 모드
- 로드 밸런서가 라우팅 역할을 수행하는 모드
- 로드밸런서를 기준으로 사용자 방향과 서버 방향이 서로 다른 네트워크로 분리된 구성
- 로드 밸런서는 사용자 방ㅇ향과 서버 방향의 네트워크를 라우팅으로 연결함
- 라우티드 모드는 원암구성과 인라인 구성에서 모두 구성 가능
- 보안 강화 목적으로 서버 쪽 네트워크를 사서로 구성해 서버에 직접 접속하는 것을 막는 용도로 사용되기도 함
- 라우티드 모드에서 서비스 요청 시의 패킷 흐름
  - 사용자가 서비스 IP인 VIP 주소 10.10으로 서비스를 요청
  - 로드밸런서로 들어온 패킷은 목적지 IP 주소를 VIP에 바인딩된 실제 서버 IP 주소인 20.11로 변경
  - 라우팅을 수행하면서 로드 밸런서를 통과하므로 일반 라우팅과 동일하게 출발지와 목적지의 mAC 주소도 각각 변경됨
  - 목적지 IP와 출발지/목적지MAC이 변경된 패킷은 라우팅 테이블을 확인해 실제 서버로 전송됨
  - 이 과정에서 로드 밸런서는 서비스를 위헌 VIP에서 실제 서버의 IP 주소로 변경해 전송하므로 Destination NAT 가 되이써다고 함
- 라우티드 모드에서 서비스 응답 시의 패킷 흐름
  - 출발지가 실제 서버의 IP 주소가 되고 목적지 IP는 원래 사용자의 IP 주소가 됨
  - 목적지 IP가 외부네트워크 이므로 목적지 MAC은 외부로 나가는 관문인 로드밸런서의 MAC 주소가 됨
  - 로드 밸런서로 들어온 패킷은 출발지 IP 주소를 실제 서버의 IP 인 20.11엥서 사용자가 서비스를 위해 요청했던 VIP로 변경함
  - 요청 트래픽과 마찬가지로 출발지와 목적지의 MAC 주소를 변경한 후 사용자에게 응답 패킷을 전송함

### DSR 모드
- 사용자의 요청이 로드 밸런서를 통해 서버로 유입된 후에 다시 로드밸런서를 통하지 않고 서버가 사용자에게 직접 응답하는 모드
- 로드 밸런서에는 응답 트래픽이 유입되지 않으므로 사용자가 요청하는 패킷에 대해서만 관여함
- 원암으로 구성
- L2 DSR
  - 실제 서버의 네트워크를 로드 밸런서가 가진 경우
- L3 DSR
  - 실제 서버의 네트워크 대역을 로드밸런서가 가지지 않은 경우
- 로드 밸런서가 서버 대역을 가지고 있으면 L2 DSR이고 없으면 L3 DSR
- 요청 트래픽만 로드 밸런서를 통해 흐르므로 로드 밸런서 전체 트래픽이 감소해 로드 밸런서 부하가 감소함
- DSR모드의 서비스 응답이 로드 밸런서를 경유하지 않으므로 무제가 발생했ㅇ르 때 문제 확인이 어려움
- DSR모드의 트래픽 흐름
  - 사용자는 서비스 IP인 VIP로 서비스를 요청
  - 로드 밸런서로 들어온 서비스 요청 패킷은 로드밸런서를 거치지 않고 응답해야 하므로 출발지 IP를 변경하는 Source NAT를 수행할 수 없음
  - 따라서 로드 밸런서의 서비스 VIP가 아닌 실제 서버 IP로 응답을 받음
  - 요청했던 IP 주소와 응답을 해주는 IP주소가 다르기 때문에 사요자는 비정상적인 응답으로 간주하고 패킷을 처리하지 않음
  - 따라서 DSR모드의 경우, 로드 밸런서는 서비스를 요청할 때 목적지 IP는 실제 서버 IP로 변경하지 않고 VIP 그대로 유지하고 목적지 MAC주소만 실제 서버의 MAC 주소로 변경해 서버로 전송함
  - 서버에서는 해당 캐시을 수신할 때 목적지 IP주소가 서버의 주소와 맞지 않으면 폐기되므로 루프백 인터페이스를 생성해 VIP 주소를 할당함
  - 이 VIP는 로드 밸런서와 동일한 IP가 중복 설정된 상태이므로 ARP에 의해 중복된 IP에 대한 MAC이 갱신되지 않도록 서버에 설정된 VIP에 대해서는  ARP 광고가 되지 않도록 함
- DSR모드를 사용할 때 서버에서 해줘야 할 추가 설정
  - 루프백 인터페이스 설정
  - 리눅스 커널 파라미터 수정(리눅스)/네트워크 설정 변경(윈도우)

## 12.7 로드 밸런서 유의사항
### 원암 구성의 동일 네트워크 사용 시
- 원암 구성에서 서비스 IP와 서버가 동일 네트워크를 사용할 때의 문제
  - 원암구성에서는 로드밸런서를 거치지 않고 사용자에게 바로 응답함
  - 사용자는 10.10이라는 서비스 IP로 요청했지만 응답은 서버의 실제 IP인 10.11로 받게 되고 서비스를 호출한 사용자 입장에서는 요청하지 않은 IP에서 응답 패킷을 받았으므로 해당 패킷은 폐기됨
  - 이 문제는 로드 밸런서를 거치면서 변경된 IP가 재응답할 때 로드밸런서를 경유하면서 원래의 IP로 바꿔 응답해야하지만, 원암구조에서는 응답트래픽이 로드밸런서를 경유하지 않아서 발생함
- 해결방법
  - 게이트웨이를 로드밸런서로 설정
    - 로드 밸런서를 통해 부하 분산이 이루어지는 실제 서버에 대해서는게이트웨이를 로드 밸런서로 설정하면 로컬 네트워크가 아닌 외부 사용자의 호출에 대한 응답이 항상 로드 밸런서를 통하므로 정상적으로 응답할 수 있음
    - 다만 이 경우 물리적으로는 원암구조이지만 실제 트래픽 플ㄹ가 로드밸런서를 게이트웨이로 사용하므로 원암구조에서 가질 수 있는 로드밸런서의 부하 감소효과가 줄어듦
  - Source NAT 사용
    - 사용자의 서비스 요청에 대해 로드 밸런서가 실제 서버로 가기 위해 수행하는 Destination NAT 뿐만 아니라 출발지 IP 주소를 로드 밸런서가 가진 IP로 함게 변경함
    - 서버에서는 사용자의 요청이 아니라 로드 밸런서가 서비스 요청을 한 것으로 보이기 때문에 응답을 로드 밸런서로 보내게 됨
    - 이 경우 서비스를 호출할 떄와 응답할 때 모두 Source/Destination NAT를 함께 수행함
  - DSR 모드
    - DSR 모드는 사용자의 서비스 요청 트래픽에 대해 별도의 Destination NAT를 수행하지 않고 실제 서버로 서비스 요청 패킷을 전송
    - 각 서버에는 서비스 IP 정보가 루프백인터페이스에 서정되어 있으며 서비스에 응답할 때 루프백에 설정된 서비스 IP 주소를 출발지로 응답함

### 동일 네트워크 내에서 서비스 IP(VIP) 호출
- 인라인과 원암 구성은 동일한 네트워크 내에서 서비스 호출 시 로드 밸런서를 거치지 않고 응답하면 문제가 발생할 수 잇음
- 해결방법도 앞선 문제의 해결방법과 거의 같음
- Source nat 방법
- DSR 모드 사용
- 동일한 네트워크에서 서비스 IP 호출을 해결하는 또다른 방법은, 부하 분산 서비스를 받는 서버를 로드 밸런서에 직접 연결해 어떤 서비스 요청에 대한 응답이든 물리적으로 로드 밸런서를 거치게 하는 것
  - 비용적인 문제로 권장하지 않음

## 12.8 HAProxy를 사용한 로드밸런서 설정
- HAProxy는 기존 하드웨어 로드 배럴ㄴ서의 역할을 일반 서버에서 직접 수행하게 해주는 오픈소스 기반의 소프트웨어 로드 밸런서
- 간단한 설정만으로도 바로 사용할 수 있음
- 소프트웨어 형태이므로 가상화나 클라우드 환경에서 로드 배런서로 사용하기에 매우 적합
- 쿠버네티스의 인그레스 컨트롤러 역할도 가능

### HAProxy 설정

|섹션|설명|
|---|---|
|global|HAProxy 프로세스 전반에 적용되는 설정 값|
|defaults|부하 분산에 적용되는 기본 설정 값|
|frontend|실제 서비스에 사용될 가상 IP 관련 설정 값|
|backend|가상 IP에 전달되어 실제 서비스에 사용되는 리얼 IP에 대한 설정|
|listen|frontend와 backend 섹션을 동시에 설정할 수 있는 섹션|

