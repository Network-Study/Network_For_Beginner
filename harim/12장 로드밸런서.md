# 12장 로드밸런서
- 서비스의 안정성이나 가용량을 높이기 위해 서비스를 이중화 할 때는 서비스 자체적으로 HA 클러스터를 구성하기도 하지만, 복잡한 고려 없이 이중화를 손쉽게 구현하도록 로드밸런서를 많이 사용함
## 12.1 부하분산이란?
- 배경
  - 서비스를 단일 서버로 구성하면 해당 서버의 애플리케이션, 운영체제, 하드웨어에 장애가 발생했을 떄, 정상적인 서비스를 제공할 수 없음
  - 서비스 가용성을 높이기 위해 하나의 서비스는 보통 두 대 이상의 서버로 구성함
  - 단일 서버를 구성하거나 서버를 이중화해 서비스 호출을 분리한 경우, 서버 장애에 따라 서비스 장애가 발생함
    - 사용자에 따라 호출하는 서버의 IP가 다르기 때문에 어떤 서버에 장애가 발생하면 그 서버 IP를 이용하는 사용자는 서비스를 이용 하지 못하게 됨
  - 이런 문제점을 해결하기 위해 L4나 L7 스위치라는 **로드밸런서**를 사용함
- 로드밸런서란
  - 로드밸런서에는 동일한 서비스를 사용하는 다수의 서버가 등록되고, 사용자로부터 서비스 요청이 오면 로드밸런서가 받아 사용자별로 다수의 서버에 서비스 요청을 분산시켜 부하를 분산함
  - 로드밸런서에서는 서비스를 위한 가상 IP(VIP)를 하나 제공하고 ,사용자는 각 서버의 개별 IP 주소가 아닌 동일한 가상 IP를 통해 각 서버로 접근함
  - 각 서버의 서비스 상태를 체크해 서비스가 가능한 서버로만 사용자의 요청을 분산함

## 12.2 부하 분산 방법
- 부하를 다수의 장비에 분산시키기 위해 가상 IP 주소를 갖게됨
  - VIP(Virtual IP)라고도 하고 서비스 IP 주소라고도 함
- 각 서버의 실제 IP 주소를 Real IP (혹은 RIP)라고 함
- 로드밸런서의 가상 IP에 실제 서버들이 바인딩됨
- 사용자가 VIP로 서비스를 요청하면 해당 VIP에 연결된 리얼 IP로 해당 요청을 전달함
- ex)
|Real IP|서버 명|
|---|---|
|10.10.20.11|서버#1|
|10.10.20.12|서버#2|
|10.10.20.13|서버#3|

|VIP|서비스 포트|연결된 서버|
|---|---|---|
|10.10.10.1|http(80)|서버 #1, #2|
|10.10.10.1|https(443)|서버 #2, #3|

  - 서버는 세 대가 있음
  - 서버 1은 http, 3은 https 서비스데몬이 동작하고, 서비스 2는 http와 https서비스 데몬이 모두 동작함
  - 이 때 http 서비스는 서버 1,2 번으로 부하 분산 그룹을 설정하고, https 서비스는 서버 2,3,번으로 분산 그룹을 설정함
- 로드밸런서에 부하 분산을 위한 그룹을 만들 때는 IP 주소 뿐만 아니라 서비스 포트까지 지정해 만듦
  - 그래서 L4스위치라고도 함
  - 7계층 정보까지 확인해 처리하는 기능이 포함되는 경우에는 L7스위치라고 하기도 함
- 동일한 리얼 IP에서 서비스 포트마다 VIP를 다르게 설정할 수도 있고 리얼 IP의 서비스 포트와 ,VIP 포트도 서로 다르게 설정할 수 있음

## 12.3 헬스 체크
- 로드밸런서에서는 부하 분산을 하는 각 서버의 서비스를 주기적으로 헬스 체크해 정상적인 서비스쪽으로만 부하를 분산하고 비정상적인 서버는 서비스 그룹에서 제외해 트래픽을 보내지 않음
- 서비스 그룹에서 제외된 후에도 헬스체크를 계속 수행해 다시 정상으로 확인되면 서비스 그룹에 해당 장비를 다시 넣어 트래픽이 서버 쪽으로 보내지도록 해줌

### 헬스 체크 방식
- ICMP
  - VIP에 연결된 리얼 서버에 대해 ICMP(ping)로 헬스 체크를 수행하는 방법임
  - 단순히 서버가 살아있는지 여부만 체크하는 방법이므로 잘 사용하지 않음
- TCP 서비스 포트
  - 가장 기본적인 헬스 체크 방법
  - 로드밸런서에 설정된 서버의 서비스 포트를 확인하는 것
    1. 로드밸런서에서 서버의 서비스 포트 2000번을 등록했다면 로드밸런서에서는 리얼 IP의 2000번 포트로 SYN을 보냄
    2. 해당 리얼 IP를 가진 서버로부터 SYN,ACK를 받음
    3. 서버에 다시 ACK로 응답하고 FIN을 보내 헬스 체크를 종료함
  - SYN/SYN,ACK/ACK까지 3방향 핸드셰이크 과정
  - 실제 서비스 포트가 아닌 다른 서비스 포트로도 헬스체크를 할 수 있음
- TCP 서비스 포트: Half Open
  - TCP Half Open(절반 개방) 방식
  - 일반 TCP 서비스 포트를 확인할 때는 3방향 핸드셰이크를 거치지만, 헬스체크로 인한 부하를 줄이거나 정상적인 종료방식보다 빨리 헬스체크 세션을 끊기 위해 사용함
  - SYN을 보내고 SYN,ACK를 받지만 이후 ACK 대신 RST을 보내 세션을 끊음
- HTTP 상태 코드
  - 로드밸런서가 서버로 3방향 핸드셰이크를 거치고나서 HTTP를 요청해 정상적인 상태 코드(200 OK)를 응답하는지 여부를 체크해 헬스 체크 수행
  - TCP는 정상적으로 열리지만 웹서비스에대한 응답을 정상적으로 하지 못할 때 확인하는 방식
- 콘텐츠 확인(문자열 확인)
  - 로드밸런서에서 서버로 콘텐츠를 요청하고 응답받은 내용을 확인하여 지정된 콘텐츠가 정상적으로 응답했는지 여부를 확인하는 헬스체크 방법
  - 보통 특정 웹페이지를 호출해 사전에 지정한 문자열이 해당 웹페이지 내에 포함되어 있는지를 체크하는 기능
  - 이 헬스 체크 방식을 사용하면 로드 밸런서에서 직접 관리하는 서버의 상태 뿐만 아니라, 해당 서버의 백엔드의 상태를 해당 웹페이지로 체크할 수 있음
  - 앞단의 서버가 백엔드로 요청을 하고 백엔드에서 정상적인 결괏값으로 웹 페이지에 특정 문자열을 출력하게 해 백엔드 상태까지 확인하면서 헬스 체크를 수행하는 것
  - 유의사항
    - 단순히 서버에서 응답받은 문자열만 체크하면 정상적인 요청 결괏값이 아닌 문자열만 체크함
    - 그렇기 때문에 비정상적인 에러 코드에 대한 응답인 경우라도 해당 응답 내용에 헬스 체크를 하려 했던 문자열이 포함되어 있으면 헬스 체크를 정상으로 판단할 수 있음
    - 따라서 문자열을 이용해 헬스 체크를 수행할 때는 정상 코드 값도 중복으로 확인하거나 문자열 자체를 일반적이 아닌 특정 문자열로 지정해 결과가 정상일때만 성공하도록 해야 함

### 헬스 체크 주기와 타이머
- 주기(Interval)
  - 로드 밸런서에서 서버로 헬스 체크 패킷을 보내는 주기
- 응답 시간(Response)
  - 로드 밸런서에서 서버로 헬스 체크 패킷을 보내고 응답을 기다리는 시간
  - 해당 시간까지 응답이 오지 않으면 실패로 간주함
- 시도 횟수(Retries)
  - 로드 밸런서에서 헬스 체크 실패 시 최대 시도 횟수
  - 최대 시도 횟수 이전에 성공 시 시도 횟수는 초기화됨
- 타임 아웃(Timeout)
  - 로드밸런서에서 헬스체크 실패 시 최대 대기 시간
  - 헬스 체크 패킷을 서버로 전송한 후 이 시간 내에 성공하지 못하면 해당 서버는 다운됨
- 서비스 다운 시의 주기(Dead Interval)
  - 서비스의 기본적인 헬스 체크 주기가 아닌, 서비스 다운 시의 헬스 체크 주기
  - 서비스가 죽은 상태에서 헬스 체크 주기를 별도로 더 늘릴 때 사용

- 서비스 다운까지의 동작을 헬스 체크 주기와 시도 횟수, 응답시간으로 산정하거나 전체 타임아웃 시간으로 산정하기도 함

## 12.4 부하 분산 알고리즘
- 로드 밸런서가 리얼 서버로 부하를 분산할 때, 로드 밸런서에서는 사전에 설정한 분산 알고리즘을 ㅌㅇ해 부하 분산이 이루어짐
- 주요 분하 분산 알고리즘
  - 라운드 로빈
    - 현재 구성된 장비에 부하를 순차적으로 분산함
    - 총 누적 세션 수는 동일하지만 활성화된 세션 수는 달라질 수 있음
  - 최소 접속 방식
    - 현재 구성된 장비 중 가장 활성화된 세션 수가 적은 장비로 부하를 분산함
  - 가중치 기반 라운드 로빈
    - 라운드 로빈 방식과 동일하지만 각 장비에 가중치를 두어 가중치가 높은 장비에 부하를 더 많이 분산함
    - 처리 용량이 다른 서버에 부하를 분산하기 위한 분산 알고리즘
  - 가중치 기반 최소 접속 방식
    - 최소 접속 방식과 동일하지만 각 장비에 가중치를 부여해 가중치가 높은 장비에 부하를 더 많이 분산함
    - 처리 용량이 다른 서버에 부하를 분산하기 위한 분산 알고리즘
  - 해시
    - 해시 알고리즘을 이용한 부하 분산
    
### 라운드 로빈
- 특별한 규칙 없이 현재 구성된 장비에 순차적으로 돌아가면서 트래픽을 분산함
- EX) 서버가 세 대 있을 때 첫번째 요청은 1번 서버, 두번째 요청은 2번 서버, 세번째 요청은 3번 서버, 네번째 요청은 다시 1번 서버,,,,
- 순차적으로 모든 장비에 분산하므로 모든 장비의 총 누적 세션 수는 같아짐

### 최소 접속 방식
- 서버가 가진 세션 부하를 확인해 그것에 맞게 부하를 분산하는 방식
- 로드 밸런서에서는 서비스 요청을 각 자입로 보내줄 때마다 세션 테이블이 생성되기 때문에 각 장비에 연결된 현재 세션 수를 알 수 있음
- 최소 접속 방식은 각 장비의 세션 수를 확인해 현재 세션이 가장 적게 여녀결된 장비로 서비스 욫엉르 보내는 방식
- 서비스별로 세션 수를 관리하면서 분산해주므로 각 장비에서 처리되는 활성화 세션 수가 비슷하게 분산되면서 부하를 분산함

### 해시
- 해시 방식은 서버의 부하를 고려하지 않고 클라이언트가 같은 서버에 지속적으로 접속하도록 하기 위해 사용하는 부하 분산 방식임
- 서버 상태를 고려하는 것이 아니라 해시 알고리즘을 이용해 얻은 결괏값으로 어떤 장비로 부하를 분산할지 결정함
- 알고리즘에 의한 계산값이기 때문에 같은 알고리즘을 사용하면 항상 동일한 결괏값으로 서비스를 분산할 수 있음
- 알고리즘 계산에 사용되는 값들은 주로 출발지 IP 주소, 목적지 IP 주소, 출발지 서비스 포트, 목적지 서비스 포트를 사용함

### 장단점
- 라운드로빈, 최소접속방식은 부하를 비교적 비슷한 비율로 분산시킬 수 있다는 장점이 있음
- 하지만 동일한 출발지에서 로드 밸런서를 거친 서비스 요청이 처음 분산된 서버와 그 다음요청이 분산된 서버가 달라질 수 있어, 각 서버에서 세션을 유지해야 하는 서비스는 정상적으로 서비스되지 않음
- 해시방식은 항상 동일한 장비로 서비스가 분산된다는 장점이 있기 때문에 세션을 유지해야 하는 서비스에 적합한 분산방식임
- 하지만 알고리즘의 결괏값이 특정한 값으로 치우치면 부하 분산 비율이 한쪽으로 치우칠 수도 있음
- 서버 애플리케이션 개발에 여러 대의 서버가 사용될 것을 고려하지 않고 개발한 경우 해시를 사용함

## 12.5 로드 밸런서 구성 방식
- 구성 위치에 따라 2가지로 나눔
  - 원암(One-Arm) 구성
    - 로드 밸런서가 중간 스위치 옆에 연결되는 구성
    - 부하 분산을 수행하는 트래픽에 대해서만 로드 밸런서를 경유하고, 부하 분산을 수행하지 않는 트래픽은 로드 밸런서를 경유하지 않고 통신할 수 있음
  - 인라인(Inline) 구성
    - 서버로 가는 경로 상에 로드밸런서가 연결되는 구성
    - 부하 분산을 포함한 모든 트래픽이 로드 밸런서를 경유하는 구성

### 원암 구성
- 로드 밸런서가 중간 스위치 옆에 연결되는 구성
- LACP와 같이 다수의 인터페이스로 스위치와 연결된 경우에도 스위치 옆에 있는 구성이라면 원암 구성이라고 함
- 로드 밸런서와 스위치 간 두 개 이상의 인터페이스를 LACP가 아닌 서로 다른 네트워크로 로드 밸런서와 구성한 경우에도 원암 구성이 될 수 있음
- 트래픽이 로드 밸런서를 경유하는지 여부는 부하 분산을 이용한 트래픽인지 여부로 구분할 수 있음
- 부하 분산을 이용할 때는 로드 밸런서를 경유함
- 부하 분산을 이용하지 않을 때는 로드 밸런서를 경유하지 않음

### 인라인 구성
- 로드밸런서가 스위치에서 서버까지 가는 일직선상 경로에 있는 형태
- 트래픽이 흐르는 경로에 로드 밸런서가 있어서 서버로 향하는 트래픽이 로드 밸런서의 서비스를 받는지 여부와 상관없이 로드밸런서를 모두 통과함
- 모든 트래픽이 동일한 경로로 흐르므로 구성이 직관적이고 이해하기 쉬움
- 대신 모든 트래픽이 로드 밸런서를 경유하므로 로드 밸런서의 부하가 높아짐
- 인라인으로 로드밸런서를 선정할 때는 로드 밸런싱 성능과 패킷 스루풋 성능을 구별해 디자인 해야 함

